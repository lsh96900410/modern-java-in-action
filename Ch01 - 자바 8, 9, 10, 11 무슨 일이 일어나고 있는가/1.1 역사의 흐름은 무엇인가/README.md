# 1.1. 역사의 흐름은 무엇인가?

자바 역사를 통틀어 가장 큰 변화가 자바 8에서 일어났다. (자바 10 - 형 추론과 관련한 약간의 변화)

자바 버전이 올라감에 따라 생긴 크고 작은 변화 덕분에 프로그램을 더 쉽게 구현할 수 있게 되었다.

ex) 사과 목록을 무게순으로 정렬하는 코드 

| 고전적 코드

```java
Collections.sort(inventory, new Comparator<Apple>() {
    public int compare(Apple apple1, Apple apple2){
        return apple1.getWeight().compareTo(apple2.getWeight());
    }
});
```

| 자바 8 코드 - 자연어에 더 가깝게 간단한 방식으로 코드 구현이 가능하다

```java
inventory.sort(Comparator.comparing(Apple::getWeight));
```

멀티코어 CPU 대중화와 같은 하드웨어적 변화도 자바 8에 영향을 미쳤다.

지금까지 대부분의 자바 프로그램은 코어 중 하나만을 사용했다. (나머지 코어는 유휴 idle 상태 및 OS, 바이러스 검사 프로그램과 파워를 공유) <br> 
자바 8이 등장하기 이전에는 나머지 코어를 활용하려면 스레드를 사용하는 게 좋았을 지도 모른다. <br>
하지만 스레드를 사용하면 관리하기 어렵고 많은 문제가 발생할 수 있다는 단점이 있다.

자바는 이러한 병렬 실행 환경을 쉽게 관리하고 에러가 덜 발생하는 방향으로 진화하려 노력했다.

- 자바 1.0: 스레드(thread), 락(lock), 메모리 모델(memory model) 지원

  특별 전문가로 구성된 프로젝트 팀이 아닌 한 이와 같은 저수준 기능을 온전히 활용하기 어려웠다.


- 자바 5: 스레드 풀(thread pool), 병렬 실행 컬렉션(concurrent collection) 등 아주 강력한 도구를 도입


- 자바 7: 병렬 실행에 도움을 줄 수 있는 포크/조인 프레임워크 제공

  └ 여전히 개발자가 활용하기는 쉽지 않았다.


- 자바 8: 병렬 실행을 새롭고 단순한 방식으로 접근할 수 있는 방법을 제공

  └ 간결한 코드, 멀티코어 프로세서의 쉬운 활용 기반

    - 자바 8에서 제공하는 새로운 기술
        - 스트림 API: 병렬 연산 지원

          (스트림을 이용하면 `synchronized` 키워드(에러를 자주 일으키고 멀티코어 CPU보다 비용이 훨씬 비쌈)를 사용하지 않아도 된다.)

        - 메소드에 코드를 전달하는 기법: 새롭고 간결한 방식으로 동작 파라미터화(behavior parameterization) 구현 가능

        - 인터페이스의 디폴트 메소드

`결국 자바8에서 추가된 스트림 API 덕분에 메서드에 코드를 전달하는 간결 기법과 인터페이스의 디폴트 메서드가 존재할 수 있다.`

- 자바 9: 리액티브 프로그래밍이라는 병렬 실행 기법 지원

  └ RxJava (리액티브 스트림 툴킷이라고도 불림)를 표준적인 방식으로 지원

메서드에 코드를 전달(결과 반환 및 다른 자료구조로 전달 가능)하는 자바 8 기법은 **함수형 프로그밍(functional-style programming)** 에서 위력을 발휘한다.

코드를 전달하거나 조합해서 자바의 강력한 프로그래밍 도구로 활용할 수 있다.