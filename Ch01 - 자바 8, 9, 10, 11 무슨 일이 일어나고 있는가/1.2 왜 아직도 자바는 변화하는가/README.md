# 1.2. 왜 아직도 자바는 변화하는가?

`우리는 시공을 초월하는 완벽한 언어를 원하지만, 현실적으로 그런 언어는 존재하지 않으며 모든 언어는 장단점을 가지고 있다.`


- 새로운 언어가 등장하면 진화하지 않은 기존 언어는 사장된다.
- 특정 분야에서 장점을 가진 언어는 다른 경쟁 언어를 도태시킨다.
- 단, Java는 1995년 첫 베타 버전이 공개된 이후로 경쟁 언어를 대신하며 커다란 생태계를 성공적으로 구축했다.

<br>

## 1.2.1 프로그래밍 언어 생태계에서 Java의 위치

### Java의 출발
- 처음부터 많은 유용한 라이브러리를 포함하는 잘 설계된 객체지향 언어로 시작
- 처음부터 스레드, 락을 이용한 동시성도 소소하게 지원했음
- 코드를 JVM 바이트 코드로 컴파일하는 특징으로 Java가 인터넷 애플릿 프로그램의 주요 언어가 됨
- 다양한 임베디드 컴퓨팅 분야(스마트카드, 토스터, 셋톱박스, 자동차 브레이크 시스템 등)를 성공적으로 장악 중
  > **📌 자바는 어떻게 대중적인 프로그래밍 언어로 성장했는가?**<br>
  > 
  > 객체지향은 1990년대, 두 가지 이유로 각광받았다.
  > 1. **캡슐화** - C 언어에 비해 소프트웨어 엔지니어링적인 문제가 훨씬 적다.
  > 2. **객체 지향의 정신적 모델** - 윈도우 96 및 그 이후의 WIMP 프로그래밍 모델에 쉽게 대응 가능 -> **모든 것은 객체다**
  > 
  > 처음에는 C/C++에 비해(애플리케이션 실행) 추가적으로 드는 비용(시간)때문에 반감이 있었지만, 하드웨어가 발전하면서 **프로그래머의 시간**이 더욱 중요한 요소로 부각 되었다.

### 프로그래밍 언어 생태계와 Java에 분 변화의 바람
#### 1) 병렬 프로세싱
- 프로그래머들이 빅데이터(테라바이트 이상의 데이터셋)라는 도전에 직면했다. **멀티코어 컴퓨터** 및 **컴퓨팅 클러스터**를 사용해 데이터를 효과적으로 처리할 필요성이 증가했다.
- 즉, 병렬 프로세싱을 활용해야 하는데 지금까지의 자바로는 충분히 대응할 수 없었다.
- Java 8 - 더욱 다양한 프로그래밍 도구 제공
    - 자바에 없던 완전히 새로운 개념들을 추가하여 현재 시장에서 요구하는 기능을 효과적으로 제공
    - 멀티코어 병렬성이 강화되었다.

#### 2) 큰 시스템의 설계 방식 
- 최근에는 외부에서 큰 하위시스템 컴포넌트를 추가하고 다른 벤더가 만든 컴포넌트를 이용해 개발하는 사례가 늘어나고 있다.
> 이러한 설계 스타일에 적응할 수 있도록 Java 8, 9 에서는 각각 default 메소드와 모듈을 제공한다.

<br>


## 1.2.2 스트림 처리 - Stream Processing 

> 스트림이란 한 번에 한 개씩 만들어지는 **연속적인 데이터 항목들의 모임**이다.<br>
> 프로그램은 입력 스트림에서 데이터를 한 개씩 읽어 들이고, 출력 스트림으로 데티러르 한 개씩 기록한다. <br>
> 즉, 어떤 프로그램의 출력 스트림은 다른 프로그램의 입력 스트림이 될 수 있다.
> - 입력 스트림 : `System.in`
> - 출력 스트림 : `System.out`


#### Java의 병렬 처리
- Java 8에는 java.util.stream 패키지에 스트림 API가 추가되었다.
    - `Stream<T>` : T 형식으로 구성된 일련의 항목을 의미한다.


- **복잡한 파이프라인 처리**
    - 스트림은 파이프라인을 만드는 데에 필요한 많은 메서드를 제공한다.
    - 기존에는 한 번에 한 항목을 처리했지만, Java 8 이후에는 `마치 데이터베이스 질의처럼` 작업을 고수준으로 추상화해서 일련의 스트림으로 처리 가능해짐

- **입력 부분을 여러 CPU 코어에 할당**
    - 스트림 파이프라인을 이용해서, 입력 부분을 여러 CPU 코어에 쉽게 할당이 가능하다.
    - 스레드를 사용하지 않으면서도 공짜로 병렬성을 얻을 수 있음

<br>

## 1.2.3. 동작 파라미터화로 메서드에 코드 전달하기

#### 동작 파라미터 - Behavior Parameterization
- 아직은 어떻게 실행할 것인지 결정하지 않은 코드 블럭 (코드 블럭의 실행은 나중으로 미뤄짐)
  ⇒ 코드 블럭에 따라 메서드의 동작이 파라미터화됨
- 즉, 메서드를 다른 메서드의 인수로 넘겨주는 기능

#### Java 8 
- Java 8 이전에는 메서드를 다른 메서드로 전달할 방법이 없었음
- Java 8 이후 동작 파라미터화로 인해, 코드 일부를 API로 전달하는 기능이 가능해졌다.
  즉, 메서드(우리 코드)를 다른 메서드의 인수로 넘겨주는 기능을 제공한다.
- 스트림 API는 연산의 동작을 파라미터화할 수 있는코드를 전달한다는 사상에 기초한다.
- 함수형 프로그래밍 분야의 기술을 응용해서 동적 파라미터를 활용하는 방법도 있음

> 💡 **동작 파라미터화**가 왜 중요할까? <br>
> Stream API는 연산의 동작을 파라미터화할 수 있는 코드를 전달한다는 사상에 기초하기 때문

<br>

## 1.2.4. 병령서과 공유 가변 데이터 

#### '병령성을 공짜로 얻을 수 있다.'
- 스트림 메서드로 전달하는 코드의 동작 방식을 조금 바꾸면 병렬성을 공짜로 얻을 수 있음

#### 스트림과 병렬성
- 스트림 메서드로 전달하는 코드는 다른 코드와 동시에 실행되더라도 안전하게 실행될 수 있어야 한다.<BR>
=> 공유된 가변 데이터(shared mutable data)에 접근하지 않아야 한다. - 순수(pure), 부작용 없는(side-effect-free), 상태 없는(stateless) 함수
- 함수형 프로그래밍 패러다임의 핵심적인 사항이다.(vs 명령형 프로그래밍 : 일련의 가변 상태로 프로그래밍을 정의함)
> 즉, 함수가 (수학적인 함수처럼) 정해진 기능만 수행하며, 다른 부작용은 일으키지 않음을 의미한다.

#### Synchronized vs Stream
- **`synchronized`** 
    - 공유된 가변 데이터를 보호하는 규칙을 만들 수 있다.
    - 단, 시스템 성능에 악영향을 미친다. - 다중 프로세싱 코어에서 사용시 코드가 순차적으로 실행되어야 하므로 병렬이라는 목적을 무력화
- **`stream`**
   - 기존의 스레드 API보다 쉽게 병렬성 활용 가능

    
<br>